#include <stdio.h>
#include <libconfig.h>
#include <getopt.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <unistd.h>

#include "dag-task.h"
#include "taskset-create.h"

/**
 * global command line configuration
 */
static struct {
	int c_verbose;
	char* c_lname;
	char* c_oname;
	char* c_tname;
	tint_t c_deadline;
	int c_bound;
	int c_implicit;	
	float c_pathf;
} clc;

static const char* short_options = "hl:o:vt:b,d:c:";
static struct option long_options[] = {
    {"help",		no_argument, 		0, 'h'},
    {"log", 		required_argument, 	0, 'l'},
    {"output", 		required_argument, 	0, 'o'},
    {"verbose", 	no_argument, 		&clc.c_verbose, 1},
    {"task",		required_argument,	0, 't'},
    {"deadline",	required_argument,	0, 'd'},
    {"implicit",	no_argument,		&clc.c_implicit, 1},
    {"bound",		no_argument,		&clc.c_bound, 1},
    {"cpath-fact",	required_argument,	0, 'c'},
    {0, 0, 0, 0}
};

static const char *usagec[] = {
"dts-deadline: DAG Task Assignment of Deadlines",
"Usage: dts-deadline -t <TASK FILE> -d <VALUE> [OPTIONS]",
"OPTIONS:",
"	-h/-help		This message",
"	-l/-log <FILE>		Auditible log file",
"	-o/--output <FILE>	Output file",
"	-v/--verbose		Verbose output",
"REQUIRED:",
"	-t/--task-file		Task file generated by dts-gen-nodes",
"ONE OF:",
"	-d/--deadline <INT>	Deadline",
"	-b/--bound 		Treat the period as an upper bound",
"	-c/--cpath-fact		Critical path length factor",
"	-i/--implicit		Use implicit deadlines",
"",
"OPERATION:",
"	dts-deadline assigns a deadline to a new task. If the -b option",
"	is provided the deadline is chosen from a random sampling in the",
"	range [1, p] where 'p' is the period of the task",
"",
"       If the -c option is provided, the deadline will be set in the range",
"	of [CF, p] where CF is the critical path length multiplied by the -c",
"	value. For example, if the critical path length is 20, the period 100,",
"	and -c 3 is given in the command line the range is : [60,100].",
"",
"	If the -i option is provided, deadlines are set equal to periods",
"",
"EXAMPLES:"
"	# Create a task",
"	> dts-gen-nodes -n 20 -e 0.7 -o part-01.dot",
"	# Create demand",
"	> dts-demnad -t part-01.dot -j 10 -w 50 -f 0.3 -o part-02.dot",
"	# Assign period by utilization",
"	> dts-period -t part-02.dot -u 0.3 -o part-03.dot",
"	# Assign a deadline of 100",
"	> dts-deadline -t part-03.dot -d 100 -o deadline.dot",
"",
"	# Assign deadline by bound",
"	# If the task's period is 20, the deadline will be between",
"	# 20 and 100 (inclusive)",
"	> dts-deadline -t part-03.dot -d 100 -b",
};

void
usage() {
	for (int i = 0; i < sizeof(usagec) / sizeof(usagec[0]); i++) {
		printf("%s\n", usagec[i]);
	}
}

int
main(int argc, char** argv) {
	FILE *ofile = stdout;
	gsl_rng *r = NULL;
	dtask_t *task = NULL;
	int rv = -1; /* Assume failure */

	/*
	 * Initializer for the GNU Scientific Library for random numbers
	 * Suggested values for environment variables
	 *   GSL_RNG_TYPE=ranlxs2
	 *   GSL_RNG_SEED=`date +%s`
	 */
	ges_stfu();
	
	/* Parse those arguments! */
	while(1) {
		int opt_idx = 0;
		int c = getopt_long(argc, argv, short_options,
		    long_options, &opt_idx);
		if (c == -1) {
			break;
		}

		switch(c) {
		case 0:
			break;
		case 'h':
			usage();
			goto bail;
		case 'l':
			/* Needs to be implemented */
			printf("Log file not implemented\n");
			usage();
			goto bail;
		case 'o':
			clc.c_oname = strdup(optarg);
			break;
		case 't':
			clc.c_tname = strdup(optarg);
			break;
		case 'v':
			clc.c_verbose = 1;
			break;
		case 'd': 
			clc.c_deadline = atoi(optarg);
			clc.c_bound = 0;
			clc.c_pathf = 0;
			clc.c_implicit = 0;			
			break;
		case 'i': 
			clc.c_implicit = 1;
			clc.c_deadline = 0;
			clc.c_bound = 0;
			clc.c_pathf = 0;
			break;
		case 'b':
			clc.c_deadline = 0;			
			clc.c_bound = 1;
			clc.c_pathf = 0;
			clc.c_implicit = 0;
			break;
		case 'c':
			clc.c_deadline = 0;
			clc.c_bound = 0;
			clc.c_pathf = atof(optarg);
			clc.c_implicit = 0;
			break;
		default:
			printf("Unknown option %c\n", c);
			usage();
			goto bail;
		}
	}
	if (!clc.c_deadline && !clc.c_bound && !clc.c_pathf) {
		fprintf(stderr, "One of -b, -c, or -d is required\n");
		usage();
		goto bail;
	}
	if (!clc.c_tname) {
		fprintf(stderr, "--taks-file is a required option\n");
	}
	if (clc.c_oname) {
		ofile = fopen(clc.c_oname, "w");
		if (!ofile) {
			fprintf(stderr, "Unable to open %s for writing\n", clc.c_oname);
			ofile = stdout;
			goto bail;
		}
	}

	/* Read the task file */
	task = dtask_read_path(clc.c_tname);
	if (!task) {
		fprintf(stderr, "Unable to read file %s\n", clc.c_tname);
		goto bail;
	}

	/* Initialize a random source */
	r = gsl_rng_alloc(gsl_rng_default);
	/* -d option */
	if (clc.c_deadline) {
		task->dt_deadline = clc.c_deadline;
	}
	/* -b option */
	if (clc.c_bound) {
		tint_t period = task->dt_period;
		task->dt_deadline = tsc_get_scaled(r, 1, period);
		if (task->dt_deadline == 0) {
			fprintf(stderr, "Error!\n");
			goto bail;
		}
	}
	/* -c option */
	if (clc.c_pathf > 0) {
		tint_t period = task->dt_period;		
		tint_t cpathlen = dtask_cpathlen(task);
		task->dt_deadline = tsc_get_scaled(r,
		    ceil(cpathlen * clc.c_pathf), period);
		if (task->dt_deadline == 0) {
			fprintf(stderr, "Error!\n");
			goto bail;
		}
	}

	/* -i option */
	if (clc.c_implicit) {
		task->dt_deadline = task->dt_period;
	}
	
	/* Sanity check */
	if (task->dt_deadline > task->dt_period) {
		task->dt_deadline = task->dt_period;
	}
	
	dtask_update(task);
	dtask_write(task, ofile);
	
	rv = 0;
bail:
	if (task) {
		dtask_free(task);
	}
	if (clc.c_oname) {
		free(clc.c_oname);
	}
	if (clc.c_tname) {
		free(clc.c_tname);
	}
	if (r) {
		gsl_rng_free(r);
	}
	if (ofile != stdout) {
		fclose(ofile);
	}
	return rv;
}
